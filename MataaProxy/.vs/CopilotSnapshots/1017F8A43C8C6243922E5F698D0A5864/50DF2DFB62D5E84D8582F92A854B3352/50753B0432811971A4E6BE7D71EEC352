using Microsoft.AspNetCore.Mvc;
using System.Net.Http.Headers;

[Route("proxy")]
[ApiController]
public class ProxyController : ControllerBase
{
    private static readonly HashSet<string> ExcludedRequestHeaders = new(StringComparer.OrdinalIgnoreCase)
    {
        "Connection", "Proxy-Connection", "Keep-Alive", "Transfer-Encoding", "TE", "Trailer", "Upgrade",
        "Proxy-Authorization", "Proxy-Authenticate", "Host", "Content-Length"
    };

    private static readonly HashSet<string> ExcludedResponseHeaders = new(StringComparer.OrdinalIgnoreCase)
    {
        "Connection", "Proxy-Connection", "Keep-Alive", "Transfer-Encoding", "TE", "Trailer", "Upgrade",
        "Proxy-Authorization", "Proxy-Authenticate", "Content-Length", "Content-Type"
    };

    private readonly HttpClient _httpClient;

    public ProxyController(IHttpClientFactory httpClientFactory)
    {
        // Use the named client configured to accept any SSL certificate
        _httpClient = httpClientFactory.CreateClient("UnsafeProxy");
    }

    [HttpGet, HttpPost, HttpPut, HttpDelete, HttpPatch, HttpOptions, HttpHead]
    public async Task<IActionResult> Forward()
    {
        var targetUrl = Request.Query["url"].ToString();

        if (string.IsNullOrWhiteSpace(targetUrl) || !Uri.IsWellFormedUriString(targetUrl, UriKind.Absolute))
            return BadRequest("Missing or invalid 'url' query parameter.");

        var requestMessage = new HttpRequestMessage
        {
            Method = new HttpMethod(Request.Method),
            RequestUri = new Uri(targetUrl)
        };

        // If there is a request body, forward it as a stream to preserve binary content
        if (Request.ContentLength.HasValue && Request.ContentLength.Value > 0)
        {
            // Do not read to string. Stream directly.
            requestMessage.Content = new StreamContent(Request.Body);

            // Forward content headers
            if (!string.IsNullOrEmpty(Request.ContentType))
            {
                requestMessage.Content.Headers.ContentType = MediaTypeHeaderValue.Parse(Request.ContentType);
            }

            foreach (var header in Request.Headers)
            {
                if (header.Key.StartsWith("Content-", StringComparison.OrdinalIgnoreCase) &&
                    !string.Equals(header.Key, "Content-Length", StringComparison.OrdinalIgnoreCase))
                {
                    requestMessage.Content.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
                }
            }
        }

        // Copy request headers (excluding hop-by-hop and content-specific headers handled above)
        foreach (var header in Request.Headers)
        {
            if (ExcludedRequestHeaders.Contains(header.Key))
                continue;

            // Skip content headers here; already handled when content exists
            if (header.Key.StartsWith("Content-", StringComparison.OrdinalIgnoreCase))
                continue;

            requestMessage.Headers.TryAddWithoutValidation(header.Key, header.Value.ToArray());
        }

        // Send the request and begin streaming the response
        using var responseMessage = await _httpClient.SendAsync(
            requestMessage,
            HttpCompletionOption.ResponseHeadersRead,
            HttpContext.RequestAborted);

        // Set status code
        Response.StatusCode = (int)responseMessage.StatusCode;

        // Copy response headers (exclude hop-by-hop and content headers that are set explicitly)
        foreach (var header in responseMessage.Headers)
        {
            if (!ExcludedResponseHeaders.Contains(header.Key))
            {
                Response.Headers[header.Key] = header.Value.ToArray();
            }
        }

        foreach (var header in responseMessage.Content.Headers)
        {
            if (!ExcludedResponseHeaders.Contains(header.Key))
            {
                Response.Headers[header.Key] = header.Value.ToArray();
            }
        }

        // Set the Content-Type explicitly
        var contentType = responseMessage.Content.Headers.ContentType?.ToString();
        if (!string.IsNullOrWhiteSpace(contentType))
        {
            Response.ContentType = contentType;
        }

        // Stream the response body directly to the client
        await responseMessage.Content.CopyToAsync(Response.Body, HttpContext.RequestAborted);

        // We have already written the response body and headers
        return new EmptyResult();
    }
}
